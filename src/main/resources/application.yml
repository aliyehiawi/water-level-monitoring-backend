spring:
  application:
    name: water-level-monitoring-backend
  profiles:
    # Default to 'dev' for local development (best practice)
    # Production should ALWAYS explicitly set SPRING_PROFILES_ACTIVE=prod via environment variable
    default: ${SPRING_PROFILES_ACTIVE:dev}

  # Database Configuration
  # Profile-specific: database URL, driver, credentials in application-{profile}.yml
  # Shared Hikari pool settings (same across all profiles)
  datasource:
    hikari:
      connection-timeout: ${DB_POOL_CONNECTION_TIMEOUT:30000}
      idle-timeout: ${DB_POOL_IDLE_TIMEOUT:600000}
      max-lifetime: ${DB_POOL_MAX_LIFETIME:1800000}

  jpa:
    properties:
      hibernate:
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true

  # Security Configuration
  # Profile-specific: JWT_SECRET configured in application-{profile}.yml
  # Base property required for @Value injection (will be overridden by profile configs)
  security:
    jwt:
      secret: ${JWT_SECRET:d9186e580e5478f4c37fab2faca76464}
      expiration: ${JWT_EXPIRATION:86400000} # 24 hours in milliseconds

  # MQTT Configuration
  # Profile-specific configuration in application-dev.yml and application-prod.yml
  # Base properties required for @Value injection (will be overridden by profile configs)
  mqtt:
    broker:
      url: tcp://localhost:1883
    client:
      id: test-client
    connection:
      timeout-seconds: ${MQTT_CONNECTION_TIMEOUT_SECONDS:30}
    keep-alive:
      interval-seconds: ${MQTT_KEEP_ALIVE_INTERVAL_SECONDS:60}
    scheduler:
      pool-size: ${MQTT_SCHEDULER_POOL_SIZE:2}
    retry:
      max-attempts: ${MQTT_RETRY_MAX_ATTEMPTS:3}
      initial-delay-ms: ${MQTT_RETRY_INITIAL_DELAY_MS:1000}
      max-delay-ms: ${MQTT_RETRY_MAX_DELAY_MS:10000}
      multiplier: ${MQTT_RETRY_MULTIPLIER:2.0}

# Rate Limiting Configuration
rate:
  limit:
    requests-per-minute: ${RATE_LIMIT_REQUESTS_PER_MINUTE:100}
    cache-max-size: ${RATE_LIMIT_CACHE_MAX_SIZE:10000}

# CORS Configuration
# Profile-specific: allowed-origins configured in application-dev.yml and application-prod.yml
cors:
  max-age-seconds: ${CORS_MAX_AGE_SECONDS:3600}
  allowed-methods: ${CORS_ALLOWED_METHODS:GET,POST,PUT,DELETE,OPTIONS}
  allowed-headers: ${CORS_ALLOWED_HEADERS:*}
  allow-credentials: ${CORS_ALLOW_CREDENTIALS:true}

# Logging Configuration
# Profile-specific log levels in application-dev.yml and application-prod.yml
logging:
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level [%X{traceId}] %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level [%X{traceId}] %logger{36} - %msg%n"
  file:
    name: logs/application.log

# Swagger/OpenAPI Configuration
springdoc:
  api-docs:
    path: /api-docs
  swagger-ui:
    path: /swagger-ui.html
    operationsSorter: method
  show-actuator: true
  contact:
    name: ${SPRINGDOC_CONTACT_NAME:Water Level Monitoring Team}

# Management endpoints
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always
